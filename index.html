<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 最初的梦想</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/keji" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/weixin.png" target="_self" class="nav-list-link">WEIXIN</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/10/epoll-用法/" class="post-title-link">epoll 用法</a></h2><div class="post-info">Jul 10, 2016</div><div class="post-content"><p>一个epoll的C语言例子</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;string.h&gt;
#define MAXEVENTS 64
static int create_and_bind (char *port){
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int s,sfd;
    //将hints所在内存清0
    memset (&amp;hints, 0, sizeof(struct addrinfo));
    //设置网络参数
    hints.ai_family = AF_UNSPEC;    //返回ipv4和ipv6
    hints.ai_socktype = SOCK_STREAM;  //tcp socket
    hints.ai_flags = AI_PASSIVE;
    s = getaddrinfo(NULL, port, &amp;hints, &amp;result);
    if(s != 0){
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(s));
        return -1;
    }
    //循环常见绑定socket
    for(rp=result; rp != NULL; rp=rp-&gt;ai_next){
        //创建socket
        sfd = socket(rp-&gt;ai_family,rp-&gt;ai_socktype,rp-&gt;ai_protocol);
        if(sfd == -1){
            continue;
        }
        //绑定socket
        s = bind(sfd,rp-&gt;ai_addr,rp-&gt;ai_addrlen);
        //成功就退出
        if(s == 0){
            break;
        }
        close(sfd);
    }
    //没有绑定成功
    if(rp == NULL){
        fprintf(stderr,&quot;Couldn&apos;t bind\n&quot;);
    }
    //释放资源
    freeaddrinfo(result);
    return sfd;
}
static int make_socket_non_blocking (int sfd){
    int flags,s;
    flags = fcntl (sfd, F_GETFL, 0);
    if(flags == -1){
        perror(&quot;fcntl&quot;);
        return -1;
    }
    //设置非阻塞标志
    flags |= O_NONBLOCK;
    //重置flags
    s = fcntl (sfd, F_SETFL, flags);
    if(s == -1){
        perror (&quot;fcntl&quot;);
        return -1;
    }
    return 0;
}
int main(int argc, char *argv[]){
    int sfd, s;
    int efd;
    struct epoll_event event;
    struct epoll_event *events;
    if(argc != 2){
        fprintf(stderr, &quot;Usage: %s [port]\n&quot;,argv[0]);
        exit(EXIT_FAILURE);
    }
    sfd = create_and_bind(argv[1]);
    if(sfd == -1){
        abort ();
    }
    s = make_socket_non_blocking(sfd);
    if(s == -1){
        perror(&quot;make socket no blocking&quot;);
        abort();
    }
    //监听端口
    s = listen (sfd, SOMAXCONN);
    if (s == -1)
    {
        perror (&quot;listen&quot;);
        abort ();
    }
    efd = epoll_create1(0);
    if(efd == -1){
        perror(&quot;epoll_create&quot;);
        abort();
    }
    event.data.fd = sfd;
    event.events = EPOLLIN | EPOLLET;//读入，边缘触发方式
    s = epoll_ctl(efd,EPOLL_CTL_ADD,sfd,&amp;event);
    if(s == -1){
        perror(&quot;epoll_ctl&quot;);
        abort();
    }
    //分配内存
    events = calloc(MAXEVENTS,sizeof event);
    //主循环
    while(1){
        int n,i;
        n = epoll_wait(efd,events,MAXEVENTS, -1);
        for(i = 0;i &lt; n; i++){
            if((events[i].events &amp; EPOLLERR)||
               (events[i].events &amp; EPOLLHUP) ||
               (!(events[i].events &amp; EPOLLIN))){
                fprintf(stderr, &quot;epoll error\n&quot;);
                close(events[i].data.fd);
                continue;
            }else if(sfd == events[i].data.fd){
                //有客户端连接请求
                while(1){
                    struct sockaddr in_addr;
                    socklen_t in_len;
                    int infd;
                    char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
                    in_len = sizeof in_addr;
                    infd = accept(sfd, &amp;in_addr, &amp;in_len);
                    if(infd == -1){
                        if((errno == EAGAIN) ||
                        (errno == EWOULDBLOCK)) {
                            //所有连接都处理了
                            break;
                        }else{
                            perror (&quot;accept&quot;);
                            break;
                        }
                    }
                    //转换地址
                    s = getnameinfo(&amp;in_addr,in_len,hbuf,sizeof hbuf,sbuf, sizeof sbuf,NI_NUMERICHOST|NI_NUMERICSERV);
                    if(s == 0){
                        printf(&quot;accept connetcion on %d (host=%s, port=%s)\n&quot;,infd,hbuf,sbuf);
                    }
                    s = make_socket_non_blocking(infd);
                    if(s == -1){
                        abort();
                    }
                    event.data.fd = infd;
                    event.events = EPOLLIN | EPOLLET;
                    s = epoll_ctl(efd,EPOLL_CTL_ADD,infd,&amp;event);
                    if(s == -1){
                        perror(&quot;epoll_ctl&quot;);
                        abort();
                    }
                }
                continue;
            }else{
                //客户端连接传输的数据接收
                int done = 0;
                while(1){
                    ssize_t count;
                    char buf[512];
                    count = read(events[i].data.fd,buf,sizeof(buf));
                    if(count == -1){
                        //当errno == EAGAIN 时表示数据已经读完
                        if(errno != EAGAIN){
                            perror(&quot;read&quot;);
                            done = 1;
                        }
                        break;
                    }else if(count == 0){
                        //数据读完
                        done = 1;
                        break;
                    }
                    s = write (1, buf, count);
                    if(s == -1){
                        perror(&quot;write&quot;);
                        abort();
                    }
                }
                if(done){
                    printf(&quot;close connection on %d\n&quot;,events[i].data.fd);
                    close(events[i].data.fd);
                }
            }
        }
    }
    free(events);
    close(sfd);
    return EXIT_SUCCESS;
}
</code></pre><p>参考自<br><a href="https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/">https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/</a><br><a href="http://blog.csdn.net/xiajun07061225/article/details/9250579">http://blog.csdn.net/xiajun07061225/article/details/9250579</a><br></div><a href="/2016/07/10/epoll-用法/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/07/03/shell-脚本命令总结/" class="post-title-link">shell 脚本命令总结</a></h2><div class="post-info">Jul 3, 2016</div><div class="post-content"></div><a href="/2016/07/03/shell-脚本命令总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/06/28/Android-测试框架/" class="post-title-link">Android 测试框架</a></h2><div class="post-info">Jun 28, 2016</div><div class="post-content"><p>adb shell am instrument -w -e class android.content.cts.ContentResolverSyncTestCase com.android.cts.content/android.support.test.runner.AndroidJUnitRunner</p>
<p>参考 <a href="https://developer.android.com/studio/test/command-line.html">https://developer.android.com/studio/test/command-line.html</a><br></div><a href="/2016/06/28/Android-测试框架/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/06/19/一些关于style和attr的使用问题/" class="post-title-link">一些关于style和attr的使用问题</a></h2><div class="post-info">Jun 19, 2016</div><div class="post-content"><p><a href="http://blog.csdn.net/wanjf_912/article/details/7641184">http://blog.csdn.net/wanjf_912/article/details/7641184</a><br></div><a href="/2016/06/19/一些关于style和attr的使用问题/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/06/04/重装ubuntu系统后的home挂载问题/" class="post-title-link">重装ubuntu系统后的home挂载问题</a></h2><div class="post-info">Jun 4, 2016</div><div class="post-content"><p>ubuntu系统从16.04重装为14.04时,因为原来16.04的home目录是挂载的一个独立分区不和/分区一起的,<br>但是重装网14.04后,home分区并没有用16.04的home分区,而是在/分区下的一个新的/home 导致原来的配置<br>信息不能使用,解决方法是重新将原home分区挂载到/home下<br></div><a href="/2016/06/04/重装ubuntu系统后的home挂载问题/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/24/android-json-解析/" class="post-title-link">android json 解析</a></h2><div class="post-info">May 24, 2016</div><div class="post-content"></div><a href="/2016/05/24/android-json-解析/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/23/hexo-博客工具/" class="post-title-link">hexo 博客工具</a></h2><div class="post-info">May 23, 2016</div><div class="post-content"><p>hexo new “xxxxx” 创建新页面<br>hexo g 生成页面<br></div><a href="/2016/05/23/hexo-博客工具/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/23/git-命令总结/" class="post-title-link">git 命令总结</a></h2><div class="post-info">May 23, 2016</div><div class="post-content"><p>查询某一样的修改记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git blame xxx.java | grep <span class="string">"需要查询的字符串"</span></span><br></pre></td></tr></table></figure></p></div><a href="/2016/05/23/git-命令总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/07/Android-总结/" class="post-title-link">Android 总结</a></h2><div class="post-info">May 7, 2016</div><div class="post-content"><h2 id="Android-TextView-间距调整"><a href="#Android-TextView-间距调整" class="headerlink" title="Android TextView 间距调整"></a>Android TextView 间距调整</h2><p>通过设置<br>    android:lineSpacingExtra=”12dip” //设置间距<br>    android:lineSpacingMultipier=”2” //设置行间距的倍数<br>    android:includeFontPadding=”false” //取消默认首行尾行的默认padding间距<br></div><a href="/2016/05/07/Android-总结/" class="read-more">...阅读全文</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/05/02/Android-命令/" class="post-title-link">Android 命令</a></h2><div class="post-info">May 2, 2016</div><div class="post-content"></div><a href="/2016/05/02/Android-命令/" class="read-more">...阅读全文</a></article></li></ul></section><footer><div class="paginator"><a href="/page/2/" class="next">下一页</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com">Cao KeJi</a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>